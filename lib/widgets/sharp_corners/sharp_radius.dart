import 'dart:ui';

class SharpRadius extends Radius {
  const SharpRadius({
    required double cornerRadius,
    required this.sharpRatio,
  }) : super.circular(cornerRadius);

  final double sharpRatio;
  double get cornerRadius => x;

  static const zero = SharpRadius(
    cornerRadius: 0,
    sharpRatio: 0,
  );

  /// Unary negation operator.
  ///
  /// Returns a Radius with the distances negated.
  ///
  /// Radiuses with negative values aren't geometrically meaningful, but could
  /// occur as part of expressions. For example, negating a radius of one pixel
  /// and then adding the result to another radius is equivalent to subtracting
  /// a radius of one pixel from the other.
  @override
  Radius operator -() => SharpRadius(
        cornerRadius: -cornerRadius,
        sharpRatio: sharpRatio,
      );

  /// Binary subtraction operator.
  ///
  /// Returns a radius whose [x] value is the left-hand-side operand's [x]
  /// minus the right-hand-side operand's [x] and whose [y] value is the
  /// left-hand-side operand's [y] minus the right-hand-side operand's [y].
  @override
  Radius operator -(Radius other) {
    if (other is SharpRadius) {
      return SharpRadius(
        cornerRadius: cornerRadius - other.cornerRadius,
        sharpRatio: (sharpRatio + other.sharpRatio) / 2,
      );
    }
    return SharpRadius(
      cornerRadius: cornerRadius - other.x,
      sharpRatio: sharpRatio,
    );
  }

  /// Binary addition operator.
  ///
  /// Returns a radius whose [x] value is the sum of the [x] values of the
  /// two operands, and whose [y] value is the sum of the [y] values of the
  /// two operands.
  @override
  Radius operator +(Radius other) {
    if (other is SharpRadius) {
      return SharpRadius(
        cornerRadius: cornerRadius + other.cornerRadius,
        sharpRatio: (sharpRatio + other.sharpRatio) / 2,
      );
    }
    return SharpRadius(
      cornerRadius: cornerRadius + other.x,
      sharpRatio: sharpRatio,
    );
  }

  /// Multiplication operator.
  ///
  /// Returns a radius whose coordinates are the coordinates of the
  /// left-hand-side operand (a radius) multiplied by the scalar
  /// right-hand-side operand (a double).
  @override
  SharpRadius operator *(double operand) => SharpRadius(
        cornerRadius: cornerRadius * operand,
        sharpRatio: sharpRatio * operand,
      );

  /// Division operator.
  ///
  /// Returns a radius whose coordinates are the coordinates of the
  /// left-hand-side operand (a radius) divided by the scalar right-hand-side
  /// operand (a double).
  @override
  SharpRadius operator /(double operand) => SharpRadius(
        cornerRadius: cornerRadius / operand,
        sharpRatio: sharpRatio / operand,
      );

  /// Integer (truncating) division operator.
  ///
  /// Returns a radius whose coordinates are the coordinates of the
  /// left-hand-side operand (a radius) divided by the scalar right-hand-side
  /// operand (a double), rounded towards zero.
  @override
  SharpRadius operator ~/(double operand) => SharpRadius(
        cornerRadius: (cornerRadius ~/ operand).toDouble(),
        sharpRatio: (sharpRatio ~/ operand).toDouble(),
      );

  /// Modulo (remainder) operator.
  ///
  /// Returns a radius whose coordinates are the remainder of dividing the
  /// coordinates of the left-hand-side operand (a radius) by the scalar
  /// right-hand-side operand (a double).
  @override
  SharpRadius operator %(double operand) => SharpRadius(
        cornerRadius: cornerRadius % operand,
        sharpRatio: sharpRatio % operand,
      );

  /// Linearly interpolate between two smooth radii.
  ///
  /// If either is null, this function substitutes [SharpRadius.zero] instead.
  ///
  /// The `t` argument represents position on the timeline, with 0.0 meaning
  /// that the interpolation has not started, returning `a` (or something
  /// equivalent to `a`), 1.0 meaning that the interpolation has finished,
  /// returning `b` (or something equivalent to `b`), and values in between
  /// meaning that the interpolation is at the relevant point on the timeline
  /// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
  /// 1.0, so negative values and values greater than 1.0 are valid (and can
  /// easily be generated by curves such as [Curves.elasticInOut]).
  ///
  /// Values for `t` are usually obtained from an [Animation<double>], such as
  /// an [AnimationController].
  static SharpRadius? lerp(SharpRadius? a, SharpRadius? b, double t) {
    if (b == null) {
      if (a == null) {
        return null;
      } else {
        final double k = 1.0 - t;
        return SharpRadius(
          cornerRadius: a.cornerRadius * k,
          sharpRatio: a.sharpRatio * k,
        );
      }
    } else {
      if (a == null) {
        return SharpRadius(
          cornerRadius: b.cornerRadius * t,
          sharpRatio: b.sharpRatio * t,
        );
      } else {
        return SharpRadius(
          cornerRadius: lerpDouble(a.cornerRadius, b.cornerRadius, t) ?? 0,
          sharpRatio: lerpDouble(a.sharpRatio, b.sharpRatio, t) ?? 0,
        );
      }
    }
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (runtimeType != other.runtimeType) return false;

    return other is SharpRadius &&
        other.cornerRadius == cornerRadius &&
        other.sharpRatio == sharpRatio;
  }

  @override
  int get hashCode => Object.hash(cornerRadius, sharpRatio);

  @override
  String toString() {
    return 'FlutterRadius('
        'cornerRadius: ${cornerRadius.toStringAsFixed(2)},'
        'sharpRatio: ${sharpRatio.toStringAsFixed(2)},'
        ')';
  }
}
